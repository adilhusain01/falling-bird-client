// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title GoofyBirdToken
 * @dev ERC20 token with integrated betting system for the Goofy Bird Drop game
 */
contract GoofyBirdToken is ERC20, Ownable, Pausable, ReentrancyGuard {
    uint256 public constant INITIAL_SUPPLY = 1000000 * 10**18; // 1 million tokens
    uint256 public constant FAUCET_AMOUNT = 1000 * 10**18; // 1000 tokens per faucet claim
    
    // Faucet system
    mapping(address => uint256) public lastFaucetClaim;
    uint256 public faucetCooldown = 24 hours;
    
    // Betting system
    struct Bet {
        uint256 amount;
        uint256 multiplier; // Multiplier in basis points (10000 = 1.0x, 15000 = 1.5x)
        bool claimed;
        bool exists;
    }
    
    mapping(address => mapping(bytes32 => Bet)) public bets;
    mapping(address => uint256) public pendingWinnings;
    uint256 public treasuryBalance;
    uint256 public totalBetsPlaced;
    uint256 public totalWinningsClaimed;
    
    event FaucetClaim(address indexed user, uint256 amount);
    event BetPlaced(address indexed player, bytes32 indexed betId, uint256 amount);
    event BetWon(address indexed player, bytes32 indexed betId, uint256 amount, uint256 multiplier, uint256 winnings);
    event BetLost(address indexed player, bytes32 indexed betId, uint256 amount);
    event WinningsClaimed(address indexed player, uint256 amount);
    event TreasuryWithdraw(address indexed owner, uint256 amount);
    
    constructor(address initialOwner) ERC20("Goofy Bird Token", "GBT") Ownable(initialOwner) {
        _mint(initialOwner, INITIAL_SUPPLY);
    }
    
    /**
     * @dev Allows users to claim free tokens from faucet (testnet only)
     */
    function claimFaucet() external whenNotPaused {
        require(
            block.timestamp >= lastFaucetClaim[msg.sender] + faucetCooldown,
            "Faucet cooldown not met"
        );
        
        lastFaucetClaim[msg.sender] = block.timestamp;
        _mint(msg.sender, FAUCET_AMOUNT);
        
        emit FaucetClaim(msg.sender, FAUCET_AMOUNT);
    }
    
    /**
     * @dev Check if user can claim from faucet
     */
    function canClaimFaucet(address user) external view returns (bool) {
        return block.timestamp >= lastFaucetClaim[user] + faucetCooldown;
    }
    
    /**
     * @dev Get time until next faucet claim
     */
    function timeUntilNextClaim(address user) external view returns (uint256) {
        uint256 nextClaimTime = lastFaucetClaim[user] + faucetCooldown;
        if (block.timestamp >= nextClaimTime) {
            return 0;
        }
        return nextClaimTime - block.timestamp;
    }
    
    /**
     * @dev Mint tokens (only owner)
     */
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
    
    /**
     * @dev Burn tokens
     */
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
    
    /**
     * @dev Set faucet cooldown (only owner)
     */
    function setFaucetCooldown(uint256 _cooldown) external onlyOwner {
        faucetCooldown = _cooldown;
    }
    
    // ==================== BETTING SYSTEM ====================
    
    /**
     * @dev Place a bet by transferring tokens to the contract treasury
     * @param betId Unique identifier for this bet (generated by frontend)
     * @param amount Amount of tokens to bet
     */
    function placeBet(bytes32 betId, uint256 amount) external nonReentrant whenNotPaused {
        require(amount > 0, "Bet amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient token balance");
        require(!bets[msg.sender][betId].exists, "Bet ID already exists");
        
        // Transfer tokens from user to contract
        _transfer(msg.sender, address(this), amount);
        
        // Record the bet
        bets[msg.sender][betId] = Bet({
            amount: amount,
            multiplier: 0, // Will be set when game ends
            claimed: false,
            exists: true
        });
        
        treasuryBalance += amount;
        totalBetsPlaced += amount;
        
        emit BetPlaced(msg.sender, betId, amount);
    }
    
    /**
     * @dev Record a winning bet with multiplier (called by game system)
     * @param player Address of the player
     * @param betId The bet identifier
     * @param multiplier Multiplier in basis points (10000 = 1.0x, 15000 = 1.5x)
     */
    function recordWin(address player, bytes32 betId, uint256 multiplier) external onlyOwner {
        Bet storage bet = bets[player][betId];
        require(bet.exists, "Bet does not exist");
        require(bet.multiplier == 0, "Bet already settled");
        require(multiplier >= 10000, "Multiplier must be at least 1.0x");
        
        bet.multiplier = multiplier;
        
        // Calculate winnings: bet amount * multiplier / 10000
        uint256 winnings = (bet.amount * multiplier) / 10000;
        
        // Add winnings to pending
        pendingWinnings[player] += winnings;
        
        emit BetWon(player, betId, bet.amount, multiplier, winnings);
    }
    
    /**
     * @dev Record a losing bet (called by game system)
     * @param player Address of the player
     * @param betId The bet identifier
     */
    function recordLoss(address player, bytes32 betId) external onlyOwner {
        Bet storage bet = bets[player][betId];
        require(bet.exists, "Bet does not exist");
        require(bet.multiplier == 0, "Bet already settled");
        
        // Set multiplier to 0 to mark as lost
        bet.multiplier = 1; // 1 means loss (below 1.0x threshold)
        
        // Lost bets stay in treasury (already transferred in placeBet)
        emit BetLost(player, betId, bet.amount);
    }
    
    /**
     * @dev Claim pending winnings
     */
    function claimWinnings() external nonReentrant whenNotPaused {
        uint256 winnings = pendingWinnings[msg.sender];
        require(winnings > 0, "No winnings to claim");
        require(balanceOf(address(this)) >= winnings, "Insufficient contract balance");
        
        pendingWinnings[msg.sender] = 0;
        treasuryBalance -= winnings;
        totalWinningsClaimed += winnings;
        
        _transfer(address(this), msg.sender, winnings);
        
        emit WinningsClaimed(msg.sender, winnings);
    }
    
    /**
     * @dev Mark a bet as claimed (when user claims their winnings)
     * @param betId The bet identifier
     */
    function markBetClaimed(bytes32 betId) external {
        Bet storage bet = bets[msg.sender][betId];
        require(bet.exists, "Bet does not exist");
        require(bet.multiplier > 10000, "Can only claim winning bets");
        require(!bet.claimed, "Bet already claimed");
        
        bet.claimed = true;
    }
    
    /**
     * @dev Get bet details
     * @param player Address of the player
     * @param betId The bet identifier
     */
    function getBet(address player, bytes32 betId) external view returns (uint256 amount, uint256 multiplier, bool claimed, bool exists) {
        Bet memory bet = bets[player][betId];
        return (bet.amount, bet.multiplier, bet.claimed, bet.exists);
    }
    
    /**
     * @dev Get pending winnings for a player
     * @param player Address of the player
     */
    function getPendingWinnings(address player) external view returns (uint256) {
        return pendingWinnings[player];
    }
    
    /**
     * @dev Get treasury statistics
     */
    function getTreasuryStats() external view returns (uint256 balance, uint256 totalBets, uint256 totalWinnings) {
        return (treasuryBalance, totalBetsPlaced, totalWinningsClaimed);
    }
    
    /**
     * @dev Owner can withdraw excess treasury funds (house edge)
     * This should only be used for excess funds, not active winnings
     */
    function withdrawTreasuryExcess(uint256 amount) external onlyOwner nonReentrant {
        require(amount <= treasuryBalance, "Cannot withdraw more than treasury balance");
        
        // Calculate total pending winnings across all users
        // In a production system, you'd want to track this more efficiently
        require(balanceOf(address(this)) >= amount, "Insufficient contract balance");
        
        treasuryBalance -= amount;
        _transfer(address(this), msg.sender, amount);
        
        emit TreasuryWithdraw(msg.sender, amount);
    }
    
    /**
     * @dev Pause contract (only owner)
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause contract (only owner)
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Override transfer to add pause functionality
     */
    function _update(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused {
        super._update(from, to, amount);
    }
}
