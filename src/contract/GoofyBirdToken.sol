// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title GoofyBirdToken
 * @dev ERC20 token with integrated betting system for the Goofy Bird Drop game
 */
contract GoofyBirdToken is ERC20, Ownable, Pausable, ReentrancyGuard {
    uint256 public constant INITIAL_SUPPLY = 1000000 * 10**18; // 1 million tokens
    uint256 public constant FAUCET_AMOUNT = 1000 * 10**18; // 1000 tokens per faucet claim
    
    // Faucet system
    mapping(address => uint256) public lastFaucetClaim;
    uint256 public faucetCooldown = 24 hours;
    
    // Betting system
    struct Bet {
        uint256 amount;
        uint256 multiplier; // Multiplier in basis points (10000 = 1.0x, 15000 = 1.5x)
        uint256 placedAt; // Block timestamp when bet was placed
        uint256 minDuration; // Minimum game duration in seconds
        uint256 maxMultiplier; // Maximum allowed multiplier for this bet
        bool claimed;
        bool settled; // Whether win/loss has been recorded
        bool exists;
    }
    
    mapping(address => mapping(bytes32 => Bet)) public bets;
    mapping(address => uint256) public pendingWinnings;
    uint256 public treasuryBalance;
    uint256 public totalBetsPlaced;
    uint256 public totalWinningsClaimed;
    
    // Anti-cheat parameters
    uint256 public constant MIN_GAME_DURATION = 1; // Minimum 1 second
    uint256 public constant MAX_MULTIPLIER = 100000; // Maximum 10x multiplier
    uint256 public constant BASE_MULTIPLIER = 10000; // 1.0x in basis points
    
    event FaucetClaim(address indexed user, uint256 amount);
    event BetPlaced(address indexed player, bytes32 indexed betId, uint256 amount);
    event BetWon(address indexed player, bytes32 indexed betId, uint256 amount, uint256 multiplier, uint256 winnings);
    event BetLost(address indexed player, bytes32 indexed betId, uint256 amount);
    event WinningsClaimed(address indexed player, uint256 amount);
    event TreasuryWithdraw(address indexed owner, uint256 amount);
    
    constructor(address initialOwner) ERC20("Goofy Bird Token", "GBT") Ownable(initialOwner) {
        _mint(initialOwner, INITIAL_SUPPLY);
    }
    
    /**
     * @dev Allows users to claim free tokens from faucet (testnet only)
     */
    function claimFaucet() external whenNotPaused {
        require(
            block.timestamp >= lastFaucetClaim[msg.sender] + faucetCooldown,
            "Faucet cooldown not met"
        );
        
        lastFaucetClaim[msg.sender] = block.timestamp;
        _mint(msg.sender, FAUCET_AMOUNT);
        
        emit FaucetClaim(msg.sender, FAUCET_AMOUNT);
    }
    
    /**
     * @dev Check if user can claim from faucet
     */
    function canClaimFaucet(address user) external view returns (bool) {
        return block.timestamp >= lastFaucetClaim[user] + faucetCooldown;
    }
    
    /**
     * @dev Get time until next faucet claim
     */
    function timeUntilNextClaim(address user) external view returns (uint256) {
        uint256 nextClaimTime = lastFaucetClaim[user] + faucetCooldown;
        if (block.timestamp >= nextClaimTime) {
            return 0;
        }
        return nextClaimTime - block.timestamp;
    }
    
    /**
     * @dev Mint tokens (only owner)
     */
    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
    
    /**
     * @dev Burn tokens
     */
    function burn(uint256 amount) external {
        _burn(msg.sender, amount);
    }
    
    /**
     * @dev Set faucet cooldown (only owner)
     */
    function setFaucetCooldown(uint256 _cooldown) external onlyOwner {
        faucetCooldown = _cooldown;
    }
    
    // ==================== BETTING SYSTEM ====================
    
    /**
     * @dev Place a bet by transferring tokens to the contract treasury
     * @param betId Unique identifier for this bet (generated by frontend)
     * @param amount Amount of tokens to bet
     * @param maxMultiplier Maximum multiplier player expects (prevents infinite wins)
     */
    function placeBet(bytes32 betId, uint256 amount, uint256 maxMultiplier) external nonReentrant whenNotPaused {
        require(amount > 0, "Bet amount must be greater than 0");
        require(balanceOf(msg.sender) >= amount, "Insufficient token balance");
        require(!bets[msg.sender][betId].exists, "Bet ID already exists");
        require(maxMultiplier >= BASE_MULTIPLIER && maxMultiplier <= MAX_MULTIPLIER, "Invalid max multiplier");
        
        // Transfer tokens from user to contract
        _transfer(msg.sender, address(this), amount);
        
        // Record the bet with anti-cheat parameters
        bets[msg.sender][betId] = Bet({
            amount: amount,
            multiplier: 0, // Will be set when game ends
            placedAt: block.timestamp,
            minDuration: MIN_GAME_DURATION,
            maxMultiplier: maxMultiplier,
            claimed: false,
            settled: false,
            exists: true
        });
        
        treasuryBalance += amount;
        totalBetsPlaced += amount;
        
        emit BetPlaced(msg.sender, betId, amount);
    }
    
    /**
     * @dev Self-record a win with built-in validation (called by player)
     * @param betId The bet identifier
     * @param multiplier Multiplier in basis points (10000 = 1.0x, 15000 = 1.5x)
     */
    function recordWin(bytes32 betId, uint256 multiplier) external nonReentrant whenNotPaused {
        Bet storage bet = bets[msg.sender][betId];
        require(bet.exists, "Bet does not exist");
        require(!bet.settled, "Bet already settled");
        require(multiplier >= BASE_MULTIPLIER, "Multiplier must be at least 1.0x");
        require(multiplier <= bet.maxMultiplier, "Multiplier exceeds maximum allowed");
        
        // Anti-cheat: Ensure minimum time has passed
        require(block.timestamp >= bet.placedAt + bet.minDuration, "Game too short - possible cheat");
        
        // Additional anti-cheat: Limit based on time (longer games = higher max multiplier)
        uint256 gameDuration = block.timestamp - bet.placedAt;
        uint256 timeBasedMaxMultiplier = BASE_MULTIPLIER + (gameDuration * 1000); // +0.1x per second
        require(multiplier <= timeBasedMaxMultiplier, "Multiplier too high for game duration");
        
        bet.multiplier = multiplier;
        bet.settled = true;
        
        // Calculate winnings: bet amount * multiplier / 10000
        uint256 winnings = (bet.amount * multiplier) / BASE_MULTIPLIER;
        
        // Add winnings to pending
        pendingWinnings[msg.sender] += winnings;
        
        emit BetWon(msg.sender, betId, bet.amount, multiplier, winnings);
    }
    
    /**
     * @dev Self-record a loss (called by player)
     * @param betId The bet identifier
     */
    function recordLoss(bytes32 betId) external nonReentrant whenNotPaused {
        Bet storage bet = bets[msg.sender][betId];
        require(bet.exists, "Bet does not exist");
        require(!bet.settled, "Bet already settled");
        
        // Anti-cheat: Ensure minimum time has passed
        require(block.timestamp >= bet.placedAt + bet.minDuration, "Game too short");
        
        bet.multiplier = 1; // 1 means loss (below 1.0x threshold)
        bet.settled = true;
        
        // Lost bets stay in treasury (already transferred in placeBet)
        emit BetLost(msg.sender, betId, bet.amount);
    }
    
    /**
     * @dev Claim pending winnings
     */
    function claimWinnings() external nonReentrant whenNotPaused {
        uint256 winnings = pendingWinnings[msg.sender];
        require(winnings > 0, "No winnings to claim");
        require(balanceOf(address(this)) >= winnings, "Insufficient contract balance");
        
        pendingWinnings[msg.sender] = 0;
        treasuryBalance -= winnings;
        totalWinningsClaimed += winnings;
        
        _transfer(address(this), msg.sender, winnings);
        
        emit WinningsClaimed(msg.sender, winnings);
    }
    
    /**
     * @dev Mark a bet as claimed (when user claims their winnings)
     * @param betId The bet identifier
     */
    function markBetClaimed(bytes32 betId) external {
        Bet storage bet = bets[msg.sender][betId];
        require(bet.exists, "Bet does not exist");
        require(bet.multiplier > 10000, "Can only claim winning bets");
        require(!bet.claimed, "Bet already claimed");
        
        bet.claimed = true;
    }
    
    /**
     * @dev Get bet details with anti-cheat info
     * @param player Address of the player
     * @param betId The bet identifier
     */
    function getBet(address player, bytes32 betId) external view returns (
        uint256 amount, 
        uint256 multiplier, 
        uint256 placedAt,
        uint256 maxMultiplier,
        bool claimed, 
        bool settled,
        bool exists
    ) {
        Bet memory bet = bets[player][betId];
        return (bet.amount, bet.multiplier, bet.placedAt, bet.maxMultiplier, bet.claimed, bet.settled, bet.exists);
    }
    
    /**
     * @dev Calculate maximum allowed multiplier for a bet based on duration
     * @param player Address of the player
     * @param betId The bet identifier
     */
    function getMaxAllowedMultiplier(address player, bytes32 betId) external view returns (uint256) {
        Bet memory bet = bets[player][betId];
        require(bet.exists, "Bet does not exist");
        
        if (block.timestamp < bet.placedAt + bet.minDuration) {
            return 0; // Game too short
        }
        
        uint256 gameDuration = block.timestamp - bet.placedAt;
        uint256 timeBasedMax = BASE_MULTIPLIER + (gameDuration * 1000); // +0.1x per second
        
        return timeBasedMax < bet.maxMultiplier ? timeBasedMax : bet.maxMultiplier;
    }
    
    /**
     * @dev Get pending winnings for a player
     * @param player Address of the player
     */
    function getPendingWinnings(address player) external view returns (uint256) {
        return pendingWinnings[player];
    }
    
    /**
     * @dev Get treasury statistics
     */
    function getTreasuryStats() external view returns (uint256 balance, uint256 totalBets, uint256 totalWinnings) {
        return (treasuryBalance, totalBetsPlaced, totalWinningsClaimed);
    }
    
    /**
     * @dev Owner can withdraw excess treasury funds (house edge)
     * This should only be used for excess funds, not active winnings
     */
    function withdrawTreasuryExcess(uint256 amount) external onlyOwner nonReentrant {
        require(amount <= treasuryBalance, "Cannot withdraw more than treasury balance");
        
        // Calculate total pending winnings across all users
        // In a production system, you'd want to track this more efficiently
        require(balanceOf(address(this)) >= amount, "Insufficient contract balance");
        
        treasuryBalance -= amount;
        _transfer(address(this), msg.sender, amount);
        
        emit TreasuryWithdraw(msg.sender, amount);
    }
    
    /**
     * @dev Emergency function to settle a bet (owner only, for stuck bets)
     * @param player Address of the player
     * @param betId The bet identifier
     * @param isWin True if it's a win, false if loss
     * @param multiplier Multiplier for wins (ignored for losses)
     */
    function emergencySettleBet(address player, bytes32 betId, bool isWin, uint256 multiplier) external onlyOwner {
        Bet storage bet = bets[player][betId];
        require(bet.exists, "Bet does not exist");
        require(!bet.settled, "Bet already settled");
        
        bet.settled = true;
        
        if (isWin) {
            require(multiplier >= BASE_MULTIPLIER && multiplier <= bet.maxMultiplier, "Invalid multiplier");
            bet.multiplier = multiplier;
            uint256 winnings = (bet.amount * multiplier) / BASE_MULTIPLIER;
            pendingWinnings[player] += winnings;
            emit BetWon(player, betId, bet.amount, multiplier, winnings);
        } else {
            bet.multiplier = 1;
            emit BetLost(player, betId, bet.amount);
        }
    }
    
    /**
     * @dev Pause contract (only owner)
     */
    function pause() external onlyOwner {
        _pause();
    }
    
    /**
     * @dev Unpause contract (only owner)
     */
    function unpause() external onlyOwner {
        _unpause();
    }
    
    /**
     * @dev Override transfer to add pause functionality
     */
    function _update(
        address from,
        address to,
        uint256 amount
    ) internal override whenNotPaused {
        super._update(from, to, amount);
    }
}
